import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import sympy as sp
from sympy import symbols, lambdify, sympify
from sympy.parsing.sympy_parser import parse_expr
from scipy.optimize import fsolve

# ========== CONFIGURACI√ìN DE LA P√ÅGINA ==========
st.set_page_config(
    page_title="M√©todos Num√©ricos",
    page_icon="üßÆ",
    layout="wide"
)

# ========== FUNCIONES AUXILIARES ==========

# Diccionario de funciones seguras para eval
safe_funcs = {
    "sin": np.sin,
    "cos": np.cos,
    "tan": np.tan,
    "exp": np.exp,
    "log": np.log,
    "log10": np.log10,
    "sqrt": np.sqrt,
    "abs": np.abs,
    "pi": np.pi,
    "e": np.e
}

user_funcs = safe_funcs.copy()

def limpiar_input(texto):
    """Convierte ^ a ** para potencias"""
    return texto.replace("^", "**")

# ===================================
# FUNCIONES PARA SISTEMAS NO LINEALES
# ===================================

def metodo_biseccion_ui():
    st.subheader("üîç M√©todo de Bisecci√≥n")
    
    st.markdown("""
    **Descripci√≥n:** Encuentra la ra√≠z de una ecuaci√≥n en un intervalo [a,b] donde f(a) y f(b) tienen signos opuestos.
    
    **F√≥rmula:** $c = \\frac{a + b}{2}$
    """)
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        ecuacion = st.text_input(
            "Ingrese la funci√≥n en x:",
            value="x**3 - x - 2",
            help="Ejemplos: x**3 - x - 2, sin(x) - x/2, exp(x) - 3*x"
        )
    
    with col2:
        tol = st.number_input("Tolerancia:", value=0.0001, format="%.6f")
    
    col_a, col_b = st.columns(2)
    with col_a:
        a = st.number_input("L√≠mite inferior (a):", value=1.0)
    with col_b:
        b = st.number_input("L√≠mite superior (b):", value=2.0)
    
    if st.button("üöÄ Calcular Bisecci√≥n", type="primary"):
        try:
            x = symbols('x')
            f = sympify(ecuacion)
            f_lambda = lambdify(x, f, 'numpy')
            
            if f_lambda(a) * f_lambda(b) > 0:
                st.error("‚ö† No hay cambio de signo en el intervalo [a,b]. Intenta otros valores.")
                return
            
            iteraciones = []
            a_original, b_original = a, b
            iteracion = 0
            c = None
            
            while abs(b - a) > tol:
                iteracion += 1
                c = (a + b) / 2
                fc = f_lambda(c)
                
                iteraciones.append({
                    "Iteraci√≥n": iteracion,
                    "a": round(a, 8),
                    "b": round(b, 8),
                    "c": round(c, 8),
                    "f(c)": round(fc, 8),
                    "Error": round(abs(b - a), 8)
                })
                
                if f_lambda(a) * fc < 0:
                    b = c
                else:
                    a = c
                
                if abs(fc) < tol:
                    break
            
            # Mostrar resultados
            col_m1, col_m2, col_m3 = st.columns(3)
            with col_m1:
                st.metric("üéØ Ra√≠z aproximada", f"{c:.8f}")
            with col_m2:
                st.metric("üî¢ Iteraciones", iteracion)
            with col_m3:
                st.metric("üìä Tolerancia", f"{tol:.6f}")
            
            # Gr√°fica y tabla en columnas
            col_graf, col_tab = st.columns([1.5, 1])
            
            with col_graf:
                st.subheader("üìà Gr√°fica de la funci√≥n")
                X = np.linspace(a_original - 1, b_original + 1, 400)
                Y = f_lambda(X)
                
                fig, ax = plt.subplots(figsize=(10, 6))
                ax.axhline(0, color='black', lw=0.8, linestyle='--')
                ax.axvline(0, color='black', lw=0.8, linestyle='--')
                ax.plot(X, Y, 'b-', linewidth=2, label=f"f(x) = {ecuacion}")
                ax.scatter(c, f_lambda(c), color='red', s=150, zorder=5, label=f"Ra√≠z ‚âà {c:.4f}")
                ax.grid(True, alpha=0.3)
                ax.legend(fontsize=10)
                ax.set_xlabel("x", fontsize=12)
                ax.set_ylabel("f(x)", fontsize=12)
                ax.set_title("M√©todo de Bisecci√≥n", fontsize=14)
                st.pyplot(fig)
            
            with col_tab:
                st.subheader("üìã Tabla de iteraciones")
                df = pd.DataFrame(iteraciones)
                st.dataframe(df, use_container_width=True, height=400)
                
                csv = df.to_csv(index=False)
                st.download_button(
                    label="‚¨áÔ∏è Descargar CSV",
                    data=csv,
                    file_name="biseccion_resultados.csv",
                    mime="text/csv"
                )
        
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")


def metodo_secante_ui():
    st.subheader("üìê M√©todo de la Secante")
    
    st.markdown("""
    **Descripci√≥n:** Similar a Newton-Raphson pero no requiere la derivada. Usa dos puntos iniciales.
    
    **F√≥rmula:** $x_{n+1} = x_n - f(x_n) \\cdot \\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}$
    """)
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        ecuacion = st.text_input(
            "Ingrese la funci√≥n en x:",
            value="x**3 - x - 2",
            key="secante_ec"
        )
    
    with col2:
        tol = st.number_input("Tolerancia:", value=0.0001, format="%.6f", key="secante_tol")
    
    col_x0, col_x1, col_max = st.columns(3)
    with col_x0:
        x0 = st.number_input("Primer valor inicial (x‚ÇÄ):", value=1.0)
    with col_x1:
        x1 = st.number_input("Segundo valor inicial (x‚ÇÅ):", value=2.0)
    with col_max:
        max_iter = st.number_input("M√°ximo de iteraciones:", value=100, min_value=1, step=1)
    
    if st.button("üöÄ Calcular Secante", type="primary"):
        try:
            x = symbols('x')
            f = sympify(ecuacion)
            f_lambda = lambdify(x, f, 'numpy')
            
            iteraciones = []
            iteracion = 0
            error = abs(x1 - x0)
            x2 = x1
            
            while error > tol and iteracion < max_iter:
                iteracion += 1
                f0 = f_lambda(x0)
                f1 = f_lambda(x1)
                
                if abs(f1 - f0) < 1e-12:
                    st.error("‚ö† Divisi√≥n por cero detectada. El m√©todo falla.")
                    return
                
                x2 = x1 - f1 * (x1 - x0) / (f1 - f0)
                error = abs(x2 - x1)
                
                iteraciones.append({
                    "Iteraci√≥n": iteracion,
                    "x‚ÇÄ": round(x0, 8),
                    "x‚ÇÅ": round(x1, 8),
                    "f(x‚ÇÅ)": round(f1, 8),
                    "x‚ÇÇ": round(x2, 8),
                    "Error": round(error, 8)
                })
                
                x0, x1 = x1, x2
            
            # Resultados
            col_m1, col_m2, col_m3 = st.columns(3)
            with col_m1:
                st.metric("üéØ Ra√≠z aproximada", f"{x2:.8f}")
            with col_m2:
                st.metric("üî¢ Iteraciones", iteracion)
            with col_m3:
                estado = "‚úÖ Convergi√≥" if error < tol else "‚ö†Ô∏è No convergi√≥"
                st.metric("Estado", estado)
            
            # Gr√°fica y tabla
            col_graf, col_tab = st.columns([1.5, 1])
            
            with col_graf:
                st.subheader("üìà Gr√°fica de la funci√≥n")
                X = np.linspace(x2 - 3, x2 + 3, 400)
                Y = f_lambda(X)
                
                fig, ax = plt.subplots(figsize=(10, 6))
                ax.axhline(0, color='black', lw=0.8, linestyle='--')
                ax.plot(X, Y, 'b-', linewidth=2, label=f"f(x) = {ecuacion}")
                ax.scatter(x2, f_lambda(x2), color='red', s=150, zorder=5, label=f"Ra√≠z ‚âà {x2:.4f}")
                ax.grid(True, alpha=0.3)
                ax.legend()
                ax.set_xlabel("x")
                ax.set_ylabel("f(x)")
                ax.set_title("M√©todo de la Secante")
                st.pyplot(fig)
            
            with col_tab:
                st.subheader("üìã Tabla de iteraciones")
                df = pd.DataFrame(iteraciones)
                st.dataframe(df, use_container_width=True, height=400)
                
                csv = df.to_csv(index=False)
                st.download_button(
                    label="‚¨áÔ∏è Descargar CSV",
                    data=csv,
                    file_name="secante_resultados.csv",
                    mime="text/csv"
                )
        
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")


def newton_raphson_2v_ui():
    st.subheader("üî¢ Newton-Raphson (2 variables)")
    
    st.markdown("""
    **Descripci√≥n:** Resuelve sistemas de 2 ecuaciones no lineales con 2 inc√≥gnitas.
    
    Ejemplo de sistema:
    - f‚ÇÅ(x,y) = x¬≤ + y¬≤ - 4
    - f‚ÇÇ(x,y) = x - y - 1
    """)
    
    col1, col2 = st.columns(2)
    with col1:
        f1_str = st.text_input("f‚ÇÅ(x,y) =", value="x**2 + y**2 - 4", help="Primera ecuaci√≥n")
    with col2:
        f2_str = st.text_input("f‚ÇÇ(x,y) =", value="x - y - 1", help="Segunda ecuaci√≥n")
    
    col_x, col_y = st.columns(2)
    with col_x:
        x0_init = st.number_input("Valor inicial x‚ÇÄ:", value=1.0)
    with col_y:
        y0_init = st.number_input("Valor inicial y‚ÇÄ:", value=1.0)
    
    if st.button("üöÄ Calcular Newton-Raphson 2V", type="primary"):
        try:
            x, y = sp.symbols("x y")
            
            f1_expr = parse_expr(f1_str, {"x": x, "y": y, **user_funcs})
            f2_expr = parse_expr(f2_str, {"x": x, "y": y, **user_funcs})
            
            f1 = lambdify((x, y), f1_expr, "numpy")
            f2 = lambdify((x, y), f2_expr, "numpy")
            
            def sistema(vars):
                return [f1(vars[0], vars[1]), f2(vars[0], vars[1])]
            
            guess = [x0_init, y0_init]
            sol = fsolve(sistema, guess)
            
            st.success(f"‚úÖ Soluci√≥n encontrada: x = {sol[0]:.6f}, y = {sol[1]:.6f}")
            
            col_m1, col_m2 = st.columns(2)
            with col_m1:
                st.metric("x", f"{sol[0]:.8f}")
            with col_m2:
                st.metric("y", f"{sol[1]:.8f}")
            
            # Gr√°fica
            st.subheader("üìà Curvas de nivel f‚ÇÅ=0 y f‚ÇÇ=0")
            
            x_vals = np.linspace(sol[0] - 3, sol[0] + 3, 200)
            y_vals = np.linspace(sol[1] - 3, sol[1] + 3, 200)
            X, Y = np.meshgrid(x_vals, y_vals)
            Z1 = f1(X, Y)
            Z2 = f2(X, Y)
            
            fig, ax = plt.subplots(figsize=(10, 7))
            ax.contour(X, Y, Z1, levels=[0], colors='blue', linewidths=2, label='f‚ÇÅ=0')
            ax.contour(X, Y, Z2, levels=[0], colors='red', linewidths=2, label='f‚ÇÇ=0')
            ax.scatter(sol[0], sol[1], color='black', s=150, zorder=5, label='Soluci√≥n')
            ax.scatter(x0_init, y0_init, color='green', s=100, marker='x', label='Punto inicial')
            ax.grid(True, alpha=0.3)
            ax.set_xlabel("x")
            ax.set_ylabel("y")
            ax.legend()
            ax.set_title("Newton-Raphson (2 variables)")
            st.pyplot(fig)
            
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")


def newton_raphson_3v_ui():
    st.subheader("üî¢ Newton-Raphson (3 variables)")
    
    st.markdown("""
    **Descripci√≥n:** Resuelve sistemas de 3 ecuaciones no lineales con 3 inc√≥gnitas.
    """)
    
    f1_str = st.text_input("f‚ÇÅ(x,y,z) =", value="x**2 + y**2 + z**2 - 9")
    f2_str = st.text_input("f‚ÇÇ(x,y,z) =", value="x + y - z - 1")
    f3_str = st.text_input("f‚ÇÉ(x,y,z) =", value="x - y + z - 1")
    
    col_x, col_y, col_z = st.columns(3)
    with col_x:
        x0_init = st.number_input("x‚ÇÄ:", value=1.0)
    with col_y:
        y0_init = st.number_input("y‚ÇÄ:", value=1.0)
    with col_z:
        z0_init = st.number_input("z‚ÇÄ:", value=1.0)
    
    if st.button("üöÄ Calcular Newton-Raphson 3V", type="primary"):
        try:
            x, y, z = sp.symbols("x y z")
            
            f1_expr = parse_expr(f1_str, {"x":x, "y":y, "z":z, **user_funcs})
            f2_expr = parse_expr(f2_str, {"x":x, "y":y, "z":z, **user_funcs})
            f3_expr = parse_expr(f3_str, {"x":x, "y":y, "z":z, **user_funcs})
            
            f1 = lambdify((x,y,z), f1_expr, "numpy")
            f2 = lambdify((x,y,z), f2_expr, "numpy")
            f3 = lambdify((x,y,z), f3_expr, "numpy")
            
            def sistema(vars):
                return [f1(vars[0],vars[1],vars[2]), 
                        f2(vars[0],vars[1],vars[2]), 
                        f3(vars[0],vars[1],vars[2])]
            
            guess = [x0_init, y0_init, z0_init]
            sol = fsolve(sistema, guess)
            
            st.success(f"‚úÖ Soluci√≥n: x={sol[0]:.6f}, y={sol[1]:.6f}, z={sol[2]:.6f}")
            
            col_m1, col_m2, col_m3 = st.columns(3)
            with col_m1:
                st.metric("x", f"{sol[0]:.8f}")
            with col_m2:
                st.metric("y", f"{sol[1]:.8f}")
            with col_m3:
                st.metric("z", f"{sol[2]:.8f}")
            
            # Gr√°fica 3D de trayectoria
            st.subheader("üìä Trayectoria de convergencia")
            
            from mpl_toolkits.mplot3d import Axes3D
            pts = [guess]
            v = np.array(guess)
            for _ in range(8):
                v = v + 0.5 * (np.array(sol) - v)
                pts.append(v.copy())
            pts = np.array(pts)
            
            fig = plt.figure(figsize=(10, 7))
            ax = fig.add_subplot(111, projection='3d')
            ax.plot(pts[:,0], pts[:,1], pts[:,2], marker='o', linewidth=2, markersize=6)
            ax.scatter(sol[0], sol[1], sol[2], color='red', s=150, label='Soluci√≥n')
            ax.scatter(guess[0], guess[1], guess[2], color='green', s=100, marker='x', label='Inicial')
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
            ax.set_title('Newton-Raphson (3 variables)')
            ax.legend()
            st.pyplot(fig)
            
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")

def newton_modificado_2v_ui():
    st.subheader("üî¢ Newton-Raphson Modificado (2 variables)")
    
    st.markdown("""
    **Descripci√≥n:** Versi√≥n modificada de Newton-Raphson que calcula expl√≠citamente la matriz Jacobiana.
    
    Usa la f√≥rmula: $X_{n+1} = X_n - J^{-1}(X_n) \\cdot F(X_n)$
    """)
    
    col1, col2 = st.columns(2)
    with col1:
        f1_str = st.text_input("f‚ÇÅ(x,y) =", value="x**2 + y**2 - 4", key="nm2v_f1")
    with col2:
        f2_str = st.text_input("f‚ÇÇ(x,y) =", value="x - y - 1", key="nm2v_f2")
    
    col_x, col_y = st.columns(2)
    with col_x:
        x0_init = st.number_input("Valor inicial x‚ÇÄ:", value=1.0, key="nm2v_x0")
    with col_y:
        y0_init = st.number_input("Valor inicial y‚ÇÄ:", value=1.0, key="nm2v_y0")
    
    col_tol, col_max = st.columns(2)
    with col_tol:
        tol = st.number_input("Tolerancia:", value=1e-6, format="%.2e", key="nm2v_tol")
    with col_max:
        max_iter = st.number_input("M√°ximo iteraciones:", value=100, min_value=1, step=1, key="nm2v_max")
    
    if st.button("üöÄ Calcular Newton Modificado 2V", type="primary"):
        try:
            x, y = sp.symbols("x y")
            
            # Limpiar entrada
            f1_str_clean = limpiar_input(f1_str)
            f2_str_clean = limpiar_input(f2_str)
            
            # Parsear expresiones
            f1 = parse_expr(f1_str_clean, {"x": x, "y": y, **user_funcs})
            f2 = parse_expr(f2_str_clean, {"x": x, "y": y, **user_funcs})
            
            # Crear vector F y calcular Jacobiano
            Fx = sp.Matrix([f1, f2])
            vars_vec = sp.Matrix([x, y])
            J = Fx.jacobian(vars_vec)
            
            # Lambdify para evaluaci√≥n num√©rica
            f_lamb = sp.lambdify((x, y), Fx, "numpy")
            J_lamb = sp.lambdify((x, y), J, "numpy")
            
            # Inicializar
            x0, y0 = x0_init, y0_init
            datos = []
            
            # Iteraciones
            for i in range(int(max_iter)):
                Fv = np.array(f_lamb(x0, y0), dtype=float).reshape(2, 1)
                Jv = np.array(J_lamb(x0, y0), dtype=float)
                
                try:
                    delta = np.linalg.solve(Jv, -Fv)
                except np.linalg.LinAlgError:
                    st.error("‚ö† Error: matriz Jacobiana singular.")
                    return
                
                x1, y1 = (np.array([x0, y0]) + delta.flatten())
                error = np.linalg.norm(delta)
                
                datos.append({
                    "Iteraci√≥n": i + 1,
                    "x‚ÇÄ": round(x0, 8),
                    "y‚ÇÄ": round(y0, 8),
                    "x‚ÇÅ": round(x1, 8),
                    "y‚ÇÅ": round(y1, 8),
                    "Error": round(error, 10)
                })
                
                if error < tol:
                    x0, y0 = x1, y1
                    break
                
                x0, y0 = x1, y1
            
            # Mostrar resultados
            if error < tol:
                st.success(f"‚úÖ Convergi√≥ en {i+1} iteraciones")
            else:
                st.warning(f"‚ö†Ô∏è No convergi√≥ completamente en {max_iter} iteraciones")
            
            col_m1, col_m2, col_m3 = st.columns(3)
            with col_m1:
                st.metric("x", f"{x0:.8f}")
            with col_m2:
                st.metric("y", f"{y0:.8f}")
            with col_m3:
                st.metric("Iteraciones", i+1)
            
            # Gr√°fica y tabla
            col_graf, col_tab = st.columns([1.5, 1])
            
            with col_graf:
                st.subheader("üìà Curvas de nivel")
                
                try:
                    x_vals = np.linspace(x0 - 3, x0 + 3, 200)
                    y_vals = np.linspace(y0 - 3, y0 + 3, 200)
                    X, Y = np.meshgrid(x_vals, y_vals)
                    Z1 = np.vectorize(lambda x, y: eval(f1_str_clean, {"x": x, "y": y, **safe_funcs}))(X, Y)
                    Z2 = np.vectorize(lambda x, y: eval(f2_str_clean, {"x": x, "y": y, **safe_funcs}))(X, Y)
                    
                    fig, ax = plt.subplots(figsize=(10, 7))
                    ax.contour(X, Y, Z1, levels=[0], colors='blue', linewidths=2, label='f‚ÇÅ=0')
                    ax.contour(X, Y, Z2, levels=[0], colors='red', linewidths=2, label='f‚ÇÇ=0')
                    ax.scatter(x0, y0, color='black', s=150, zorder=5, label='Soluci√≥n')
                    ax.scatter(x0_init, y0_init, color='green', s=100, marker='x', label='Inicial')
                    ax.grid(True, alpha=0.3)
                    ax.set_xlabel("x")
                    ax.set_ylabel("y")
                    ax.legend()
                    ax.set_title("Newton-Raphson Modificado (2V)")
                    st.pyplot(fig)
                except Exception as e:
                    st.warning(f"‚ö† No se pudo graficar: {str(e)}")
            
            with col_tab:
                st.subheader("üìã Tabla de iteraciones")
                df = pd.DataFrame(datos)
                st.dataframe(df, use_container_width=True, height=400)
                
                csv = df.to_csv(index=False)
                st.download_button(
                    label="‚¨áÔ∏è Descargar CSV",
                    data=csv,
                    file_name="newton_modificado_2v.csv",
                    mime="text/csv"
                )
        
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")

def newton_modificado_3v_ui():
    st.subheader("üî¢ Newton-Raphson Modificado (3 variables)")
    
    st.markdown("""
    **Descripci√≥n:** Versi√≥n modificada de Newton-Raphson para 3 variables con c√°lculo expl√≠cito del Jacobiano.
    """)
    
    f1_str = st.text_input("f‚ÇÅ(x,y,z) =", value="x**2 + y**2 + z**2 - 9", key="nm3v_f1")
    f2_str = st.text_input("f‚ÇÇ(x,y,z) =", value="x + y - z - 1", key="nm3v_f2")
    f3_str = st.text_input("f‚ÇÉ(x,y,z) =", value="x - y + z - 1", key="nm3v_f3")
    
    col_x, col_y, col_z = st.columns(3)
    with col_x:
        x0_init = st.number_input("x‚ÇÄ:", value=1.0, key="nm3v_x0")
    with col_y:
        y0_init = st.number_input("y‚ÇÄ:", value=1.0, key="nm3v_y0")
    with col_z:
        z0_init = st.number_input("z‚ÇÄ:", value=1.0, key="nm3v_z0")
    
    col_tol, col_max = st.columns(2)
    with col_tol:
        tol = st.number_input("Tolerancia:", value=1e-6, format="%.2e", key="nm3v_tol")
    with col_max:
        max_iter = st.number_input("M√°ximo iteraciones:", value=100, min_value=1, step=1, key="nm3v_max")
    
    if st.button("üöÄ Calcular Newton Modificado 3V", type="primary"):
        try:
            x, y, z = sp.symbols("x y z")
            
            # Limpiar entrada
            f1_str_clean = limpiar_input(f1_str)
            f2_str_clean = limpiar_input(f2_str)
            f3_str_clean = limpiar_input(f3_str)
            
            # Parsear expresiones
            f1 = parse_expr(f1_str_clean, {"x": x, "y": y, "z": z, **user_funcs})
            f2 = parse_expr(f2_str_clean, {"x": x, "y": y, "z": z, **user_funcs})
            f3 = parse_expr(f3_str_clean, {"x": x, "y": y, "z": z, **user_funcs})
            
            # Crear vector F y calcular Jacobiano
            Fx = sp.Matrix([f1, f2, f3])
            vars_vec = sp.Matrix([x, y, z])
            J = Fx.jacobian(vars_vec)
            
            # Lambdify para evaluaci√≥n num√©rica
            f_lamb = sp.lambdify((x, y, z), Fx, "numpy")
            J_lamb = sp.lambdify((x, y, z), J, "numpy")
            
            # Inicializar
            x0, y0, z0 = x0_init, y0_init, z0_init
            datos = []
            pts = [[x0, y0, z0]]
            
            # Iteraciones
            for i in range(int(max_iter)):
                Fv = np.array(f_lamb(x0, y0, z0), dtype=float).reshape(3, 1)
                Jv = np.array(J_lamb(x0, y0, z0), dtype=float)
                
                try:
                    delta = np.linalg.solve(Jv, -Fv)
                except np.linalg.LinAlgError:
                    st.error("‚ö† Error: matriz Jacobiana singular.")
                    return
                
                x1, y1, z1 = (np.array([x0, y0, z0]) + delta.flatten())
                error = np.linalg.norm(delta)
                
                datos.append({
                    "Iteraci√≥n": i + 1,
                    "x‚ÇÄ": round(x0, 8),
                    "y‚ÇÄ": round(y0, 8),
                    "z‚ÇÄ": round(z0, 8),
                    "x‚ÇÅ": round(x1, 8),
                    "y‚ÇÅ": round(y1, 8),
                    "z‚ÇÅ": round(z1, 8),
                    "Error": round(error, 10)
                })
                
                pts.append([x1, y1, z1])
                
                if error < tol:
                    x0, y0, z0 = x1, y1, z1
                    break
                
                x0, y0, z0 = x1, y1, z1
            
            # Mostrar resultados
            if error < tol:
                st.success(f"‚úÖ Convergi√≥ en {i+1} iteraciones")
            else:
                st.warning(f"‚ö†Ô∏è No convergi√≥ completamente en {max_iter} iteraciones")
            
            col_m1, col_m2, col_m3, col_m4 = st.columns(4)
            with col_m1:
                st.metric("x", f"{x0:.8f}")
            with col_m2:
                st.metric("y", f"{y0:.8f}")
            with col_m3:
                st.metric("z", f"{z0:.8f}")
            with col_m4:
                st.metric("Iteraciones", i+1)
            
            # Gr√°fica y tabla
            col_graf, col_tab = st.columns([1.5, 1])
            
            with col_graf:
                st.subheader("üìä Trayectoria 3D")
                
                try:
                    from mpl_toolkits.mplot3d import Axes3D
                    pts = np.array(pts)
                    
                    fig = plt.figure(figsize=(10, 7))
                    ax = fig.add_subplot(111, projection='3d')
                    ax.plot(pts[:, 0], pts[:, 1], pts[:, 2], marker='o', color='blue', linewidth=2, markersize=6, label="Trayectoria")
                    ax.scatter(x0, y0, z0, color='red', s=150, label='Soluci√≥n')
                    ax.scatter(x0_init, y0_init, z0_init, color='green', s=100, marker='x', label='Inicial')
                    ax.set_xlabel("x")
                    ax.set_ylabel("y")
                    ax.set_zlabel("z")
                    ax.set_title("Newton-Raphson Modificado (3V)")
                    ax.legend()
                    st.pyplot(fig)
                except Exception as e:
                    st.warning(f"‚ö† No se pudo graficar: {str(e)}")
            
            with col_tab:
                st.subheader("üìã Tabla de iteraciones")
                df = pd.DataFrame(datos)
                st.dataframe(df, use_container_width=True, height=400)
                
                csv = df.to_csv(index=False)
                st.download_button(
                    label="‚¨áÔ∏è Descargar CSV",
                    data=csv,
                    file_name="newton_modificado_3v.csv",
                    mime="text/csv"
                )
        
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")

def punto_fijo_2v_ui():
    st.subheader("üîÑ Punto Fijo (2 variables)")
    
    st.markdown("""
    **Descripci√≥n:** M√©todo iterativo donde x = g‚ÇÅ(x,y) y y = g‚ÇÇ(x,y).
    
    **F√≥rmula:** $X_{n+1} = G(X_n)$ donde $G = [g_1(x,y), g_2(x,y)]^T$
    """)
    
    st.info("Ingresa las funciones de iteraci√≥n (no las ecuaciones originales)")
    
    col1, col2 = st.columns(2)
    with col1:
        fx = st.text_input("x = g‚ÇÅ(x,y)", value="(4 - y**2) / 2", help="Funci√≥n de iteraci√≥n para x", key="pf2_fx")
    with col2:
        fy = st.text_input("y = g‚ÇÇ(x,y)", value="(x + 1)", help="Funci√≥n de iteraci√≥n para y", key="pf2_fy")
    
    col_x, col_y = st.columns(2)
    with col_x:
        x0 = st.number_input("Valor inicial x‚ÇÄ:", value=1.0, key="pf2_x0")
    with col_y:
        y0 = st.number_input("Valor inicial y‚ÇÄ:", value=1.0, key="pf2_y0")
    
    col_tol, col_max = st.columns(2)
    with col_tol:
        tol = st.number_input("Tolerancia:", value=1e-6, format="%.2e", key="pf2_tol")
    with col_max:
        max_iter = st.number_input("M√°ximo iteraciones:", value=100, min_value=1, step=1, key="pf2_max")
    
    if st.button("üöÄ Calcular Punto Fijo 2V", type="primary"):
        try:
            # Limpiar entrada
            fx_clean = limpiar_input(fx)
            fy_clean = limpiar_input(fy)
            
            # Funci√≥n de iteraci√≥n
            def g(v):
                x, y = v
                locals_dict = {"x": x, "y": y, **safe_funcs}
                return np.array([
                    eval(fx_clean, {"__builtins__": None}, locals_dict),
                    eval(fy_clean, {"__builtins__": None}, locals_dict)
                ])
            
            # Iteraciones
            datos = []
            v = np.array([x0, y0])
            convergio = False
            
            for i in range(int(max_iter)):
                try:
                    nuevo = g(v)
                    error = np.linalg.norm(nuevo - v)
                    
                    datos.append({
                        "Iteraci√≥n": i + 1,
                        "x‚ÇÄ": round(v[0], 8),
                        "y‚ÇÄ": round(v[1], 8),
                        "x‚ÇÅ": round(nuevo[0], 8),
                        "y‚ÇÅ": round(nuevo[1], 8),
                        "Error": round(error, 10)
                    })
                    
                    if error < tol:
                        v = nuevo
                        convergio = True
                        break
                    
                    v = nuevo
                    
                except Exception as e:
                    st.error(f"‚ö† Error en iteraci√≥n {i+1}: {str(e)}")
                    break
            
            # Mostrar resultados
            if convergio:
                st.success(f"‚úÖ Convergi√≥ en {i+1} iteraciones")
            else:
                st.warning(f"‚ö†Ô∏è No alcanz√≥ la tolerancia en {max_iter} iteraciones")
            
            col_m1, col_m2, col_m3 = st.columns(3)
            with col_m1:
                st.metric("x", f"{v[0]:.8f}")
            with col_m2:
                st.metric("y", f"{v[1]:.8f}")
            with col_m3:
                st.metric("Iteraciones", len(datos))
            
            # Gr√°fica y tabla
            col_graf, col_tab = st.columns([1.5, 1])
            
            with col_graf:
                st.subheader("üìà Curvas x = g‚ÇÅ(x,y) y y = g‚ÇÇ(x,y)")
                
                try:
                    x_vals = np.linspace(v[0] - 3, v[0] + 3, 200)
                    y_vals = np.linspace(v[1] - 3, v[1] + 3, 200)
                    X, Y = np.meshgrid(x_vals, y_vals)
                    
                    # Calcular g‚ÇÅ(x,y) - x y g‚ÇÇ(x,y) - y para graficar donde son cero
                    Z1 = np.vectorize(lambda x, y: eval(fx_clean, {"__builtins__": None, "x": x, "y": y, **safe_funcs}))(X, Y) - X
                    Z2 = np.vectorize(lambda x, y: eval(fy_clean, {"__builtins__": None, "x": x, "y": y, **safe_funcs}))(X, Y) - Y
                    
                    fig, ax = plt.subplots(figsize=(10, 7))
                    ax.contour(X, Y, Z1, levels=[0], colors='blue', linewidths=2, label='x = g‚ÇÅ(x,y)')
                    ax.contour(X, Y, Z2, levels=[0], colors='red', linewidths=2, label='y = g‚ÇÇ(x,y)')
                    ax.scatter(v[0], v[1], color='black', s=150, zorder=5, label='Punto fijo')
                    ax.scatter(x0, y0, color='green', s=100, marker='x', label='Inicial')
                    ax.grid(True, alpha=0.3)
                    ax.set_xlabel("x")
                    ax.set_ylabel("y")
                    ax.legend()
                    ax.set_title("M√©todo de Punto Fijo (2V)")
                    st.pyplot(fig)
                except Exception as e:
                    st.warning(f"‚ö† No se pudo graficar: {str(e)}")
            
            with col_tab:
                st.subheader("üìã Tabla de iteraciones")
                df = pd.DataFrame(datos)
                st.dataframe(df, use_container_width=True, height=400)
                
                csv = df.to_csv(index=False)
                st.download_button(
                    label="‚¨áÔ∏è Descargar CSV",
                    data=csv,
                    file_name="punto_fijo_2v.csv",
                    mime="text/csv"
                )
        
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")


def punto_fijo_3v_ui():
    st.subheader("üîÑ Punto Fijo (3 variables)")
    
    st.markdown("""
    **Descripci√≥n:** M√©todo iterativo para 3 variables donde x = g‚ÇÅ(x,y,z), y = g‚ÇÇ(x,y,z), z = g‚ÇÉ(x,y,z).
    """)
    
    st.info("Ingresa las funciones de iteraci√≥n")
    
    fx = st.text_input("x = g‚ÇÅ(x,y,z)", value="(9 - y**2 - z**2) / 3", key="pf3_fx")
    fy = st.text_input("y = g‚ÇÇ(x,y,z)", value="(1 + x - z) / 2", key="pf3_fy")
    fz = st.text_input("z = g‚ÇÉ(x,y,z)", value="(1 + x - y) / 2", key="pf3_fz")
    
    col_x, col_y, col_z = st.columns(3)
    with col_x:
        x0 = st.number_input("x‚ÇÄ:", value=1.0, key="pf3_x0")
    with col_y:
        y0 = st.number_input("y‚ÇÄ:", value=1.0, key="pf3_y0")
    with col_z:
        z0 = st.number_input("z‚ÇÄ:", value=1.0, key="pf3_z0")
    
    col_tol, col_max = st.columns(2)
    with col_tol:
        tol = st.number_input("Tolerancia:", value=1e-6, format="%.2e", key="pf3_tol")
    with col_max:
        max_iter = st.number_input("M√°ximo iteraciones:", value=100, min_value=1, step=1, key="pf3_max")
    
    if st.button("üöÄ Calcular Punto Fijo 3V", type="primary"):
        try:
            # Limpiar entrada
            fx_clean = limpiar_input(fx)
            fy_clean = limpiar_input(fy)
            fz_clean = limpiar_input(fz)
            
            # Funci√≥n de iteraci√≥n
            def g(v):
                x, y, z = v
                locals_dict = {"x": x, "y": y, "z": z, **safe_funcs}
                return np.array([
                    eval(fx_clean, {"__builtins__": None}, locals_dict),
                    eval(fy_clean, {"__builtins__": None}, locals_dict),
                    eval(fz_clean, {"__builtins__": None}, locals_dict)
                ])
            
            # Iteraciones
            datos = []
            v = np.array([x0, y0, z0])
            pts = [v.copy()]
            convergio = False
            
            for i in range(int(max_iter)):
                try:
                    nuevo = g(v)
                    error = np.linalg.norm(nuevo - v)
                    
                    datos.append({
                        "Iteraci√≥n": i + 1,
                        "x‚ÇÄ": round(v[0], 8),
                        "y‚ÇÄ": round(v[1], 8),
                        "z‚ÇÄ": round(v[2], 8),
                        "x‚ÇÅ": round(nuevo[0], 8),
                        "y‚ÇÅ": round(nuevo[1], 8),
                        "z‚ÇÅ": round(nuevo[2], 8),
                        "Error": round(error, 10)
                    })
                    
                    v = nuevo
                    pts.append(v.copy())
                    
                    if error < tol:
                        convergio = True
                        break
                    
                except Exception as e:
                    st.error(f"‚ö† Error en iteraci√≥n {i+1}: {str(e)}")
                    break
            
            # Mostrar resultados
            if convergio:
                st.success(f"‚úÖ Convergi√≥ en {i+1} iteraciones")
            else:
                st.warning(f"‚ö†Ô∏è No alcanz√≥ la tolerancia en {max_iter} iteraciones")
            
            col_m1, col_m2, col_m3, col_m4 = st.columns(4)
            with col_m1:
                st.metric("x", f"{v[0]:.8f}")
            with col_m2:
                st.metric("y", f"{v[1]:.8f}")
            with col_m3:
                st.metric("z", f"{v[2]:.8f}")
            with col_m4:
                st.metric("Iteraciones", len(datos))
            
            # Gr√°fica y tabla
            col_graf, col_tab = st.columns([1.5, 1])
            
            with col_graf:
                st.subheader("üìä Trayectoria de convergencia 3D")
                
                try:
                    from mpl_toolkits.mplot3d import Axes3D
                    pts = np.array(pts)
                    
                    fig = plt.figure(figsize=(10, 7))
                    ax = fig.add_subplot(111, projection='3d')
                    ax.plot(pts[:, 0], pts[:, 1], pts[:, 2], marker='o', color='blue', linewidth=2, markersize=6, label="Trayectoria")
                    ax.scatter(pts[-1, 0], pts[-1, 1], pts[-1, 2], color='red', s=150, label='Punto fijo')
                    ax.scatter(x0, y0, z0, color='green', s=100, marker='x', label='Inicial')
                    ax.set_xlabel("x")
                    ax.set_ylabel("y")
                    ax.set_zlabel("z")
                    ax.set_title("M√©todo de Punto Fijo (3V)")
                    ax.legend()
                    st.pyplot(fig)
                except Exception as e:
                    st.warning(f"‚ö† No se pudo graficar: {str(e)}")
            
            with col_tab:
                st.subheader("üìã Tabla de iteraciones")
                df = pd.DataFrame(datos)
                st.dataframe(df, use_container_width=True, height=400)
                
                csv = df.to_csv(index=False)
                st.download_button(
                    label="‚¨áÔ∏è Descargar CSV",
                    data=csv,
                    file_name="punto_fijo_3v.csv",
                    mime="text/csv"
                )
        
        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")

# ======================
# SISTEMAS DE ECUACIONES
# ======================

def sistemas_lineales_ui():
    st.subheader("üìê Sistemas de Ecuaciones Lineales")
    
    st.markdown("""
    **Resuelve sistemas de la forma Ax = b**
    
    Puedes elegir entre m√©todos directos e iterativos.
    """)
    
    metodo = st.selectbox(
        "Selecciona el m√©todo:",
        ["M√©todo de la Inversa", "Eliminaci√≥n de Gauss", "Gauss-Jordan", 
         "Jacobi (iterativo)", "Gauss-Seidel (iterativo)"]
    )
    
    st.info("üìù Ingresa la matriz A y el vector b del sistema Ax = b")
    
    n = st.number_input("Tama√±o del sistema (n√ón):", min_value=2, max_value=10, value=3, step=1)
    
    st.write("**Matriz A:**")
    cols_A = st.columns(int(n))
    A = []
    for i in range(int(n)):
        fila = []
        for j in range(int(n)):
            with cols_A[j]:
                val = st.number_input(f"A[{i+1},{j+1}]", value=1.0 if i==j else 0.0, key=f"a_{i}_{j}", format="%.4f")
                fila.append(val)
        A.append(fila)
    
    A = np.array(A)
    
    st.write("**Vector b:**")
    cols_b = st.columns(int(n))
    b = []
    for i in range(int(n)):
        with cols_b[i]:
            val = st.number_input(f"b[{i+1}]", value=1.0, key=f"b_{i}", format="%.4f")
            b.append(val)
    
    b = np.array(b)
    
    # Par√°metros para m√©todos iterativos
    if metodo in ["Jacobi (iterativo)", "Gauss-Seidel (iterativo)"]:
        col_tol, col_max = st.columns(2)
        with col_tol:
            tol = st.number_input("Tolerancia:", value=1e-6, format="%.2e")
        with col_max:
            max_iter = st.number_input("M√°ximo iteraciones:", value=100, min_value=1, step=1)
    
    if st.button("üöÄ Resolver Sistema", type="primary"):
        try:
            if metodo == "M√©todo de la Inversa":
                det = np.linalg.det(A)
                if abs(det) < 1e-10:
                    st.error("‚ö† El sistema no tiene soluci√≥n √∫nica (det(A) ‚âà 0)")
                    return
                
                A_inv = np.linalg.inv(A)
                x = np.dot(A_inv, b)
                
                st.success("‚úÖ Sistema resuelto usando A‚Åª¬π")
                
                col1, col2 = st.columns(2)
                with col1:
                    st.write("**Inversa de A:**")
                    st.dataframe(pd.DataFrame(A_inv), use_container_width=True)
                
                with col2:
                    st.write("**Soluci√≥n x:**")
                    sol_df = pd.DataFrame({"Variable": [f"x{i+1}" for i in range(len(x))],
                                          "Valor": x})
                    st.dataframe(sol_df, use_container_width=True)
            
            elif metodo == "Eliminaci√≥n de Gauss":
                n_size = len(b)
                M = np.hstack([A.astype(float), b.reshape(-1,1)])
                
                for k in range(n_size):
                    max_row = np.argmax(abs(M[k:,k])) + k
                    M[[k, max_row]] = M[[max_row, k]]
                    for i in range(k+1, n_size):
                        if abs(M[k][k]) < 1e-10:
                            st.error("‚ö† Divisi√≥n por cero en eliminaci√≥n")
                            return
                        factor = M[i][k] / M[k][k]
                        M[i] = M[i] - factor * M[k]
                
                x = np.zeros(n_size)
                for i in range(n_size-1, -1, -1):
                    x[i] = (M[i, -1] - np.dot(M[i,i+1:n_size], x[i+1:n_size])) / M[i,i]
                
                st.success("‚úÖ Sistema resuelto usando Eliminaci√≥n de Gauss")
                
                col1, col2 = st.columns(2)
                with col1:
                    st.write("**Matriz aumentada final:**")
                    st.dataframe(pd.DataFrame(M), use_container_width=True)
                
                with col2:
                    st.write("**Soluci√≥n x:**")
                    sol_df = pd.DataFrame({"Variable": [f"x{i+1}" for i in range(len(x))],
                                          "Valor": x})
                    st.dataframe(sol_df, use_container_width=True)
            
            elif metodo == "Gauss-Jordan":
                n_size = len(b)
                M = np.hstack([A.astype(float), b.reshape(-1,1)])
                
                for k in range(n_size):
                    if abs(M[k][k]) < 1e-10:
                        st.error("‚ö† Pivote cero en Gauss-Jordan")
                        return
                    M[k] = M[k] / M[k][k]
                    for i in range(n_size):
                        if i != k:
                            M[i] = M[i] - M[i][k] * M[k]
                
                x = M[:, -1]
                
                st.success("‚úÖ Sistema resuelto usando Gauss-Jordan")
                
                col1, col2 = st.columns(2)
                with col1:
                    st.write("**Matriz en forma identidad:**")
                    st.dataframe(pd.DataFrame(M), use_container_width=True)
                
                with col2:
                    st.write("**Soluci√≥n x:**")
                    sol_df = pd.DataFrame({"Variable": [f"x{i+1}" for i in range(len(x))],
                                          "Valor": x})
                    st.dataframe(sol_df, use_container_width=True)
            
            elif metodo == "Jacobi (iterativo)":
                n_size = len(b)
                x = np.zeros(n_size)
                historial = []
                
                for it in range(int(max_iter)):
                    x_new = np.zeros(n_size)
                    for i in range(n_size):
                        if abs(A[i][i]) < 1e-10:
                            st.error("‚ö† Diagonal con cero en Jacobi")
                            return
                        s = sum(A[i][j] * x[j] for j in range(n_size) if j != i)
                        x_new[i] = (b[i] - s) / A[i][i]
                    
                    historial.append([it+1] + list(x_new))
                    
                    if np.linalg.norm(x_new - x, ord=np.inf) < tol:
                        st.success(f"‚úÖ Convergi√≥ en {it+1} iteraciones")
                        df = pd.DataFrame(historial, columns=["Iteraci√≥n"] + [f"x{i+1}" for i in range(n_size)])
                        
                        col_res, col_tab = st.columns([1, 2])
                        with col_res:
                            st.write("**Soluci√≥n final:**")
                            sol_df = pd.DataFrame({"Variable": [f"x{i+1}" for i in range(n_size)],
                                                  "Valor": x_new})
                            st.dataframe(sol_df, use_container_width=True)
                        
                        with col_tab:
                            st.write("**Historial de iteraciones:**")
                            st.dataframe(df, use_container_width=True, height=400)
                        return
                    
                    x = x_new
                
                st.warning(f"‚ö†Ô∏è No convergi√≥ en {max_iter} iteraciones")
                df = pd.DataFrame(historial, columns=["Iteraci√≥n"] + [f"x{i+1}" for i in range(n_size)])
                st.dataframe(df, use_container_width=True, height=400)
        
        except Exception as e:
            st.error(f"‚ùå Error al resolver el sistema: {str(e)}")


# =================
# ALGEBRA MATRICIAL
# =================

def algebra_matricial_ui():
    st.subheader("üî¢ Operaciones con Matrices")
    
    operacion = st.selectbox(
        "Selecciona la operaci√≥n:",
        ["Suma de matrices", "Multiplicaci√≥n de matrices", "Determinante", "Inversa de matriz"]
    )
    
    if operacion == "Suma de matrices":
        st.info("‚ûï Suma dos matrices del mismo tama√±o")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**Matriz A:**")
            filas_a = st.number_input("Filas de A:", min_value=1, max_value=10, value=2, step=1, key="filas_a")
            cols_a = st.number_input("Columnas de A:", min_value=1, max_value=10, value=2, step=1, key="cols_a")
            
            A = []
            for i in range(int(filas_a)):
                fila = []
                cols_input = st.columns(int(cols_a))
                for j in range(int(cols_a)):
                    with cols_input[j]:
                        val = st.number_input(f"A[{i+1},{j+1}]", value=0.0, key=f"suma_a_{i}_{j}", format="%.2f")
                        fila.append(val)
                A.append(fila)
            A = np.array(A)
        
        with col2:
            st.write("**Matriz B:**")
            st.write(f"Tama√±o: {int(filas_a)}√ó{int(cols_a)}")
            
            B = []
            for i in range(int(filas_a)):
                fila = []
                cols_input = st.columns(int(cols_a))
                for j in range(int(cols_a)):
                    with cols_input[j]:
                        val = st.number_input(f"B[{i+1},{j+1}]", value=0.0, key=f"suma_b_{i}_{j}", format="%.2f")
                        fila.append(val)
                B.append(fila)
            B = np.array(B)
        
        if st.button("‚ûï Calcular Suma", type="primary"):
            resultado = A + B
            st.success("‚úÖ Suma calculada")
            st.write("**Resultado: A + B =**")
            st.dataframe(pd.DataFrame(resultado), use_container_width=True)
    
    elif operacion == "Multiplicaci√≥n de matrices":
        st.info("‚úñÔ∏è Multiplica dos matrices (columnas de A = filas de B)")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**Matriz A:**")
            filas_a = st.number_input("Filas de A:", min_value=1, max_value=10, value=2, step=1, key="mult_filas_a")
            cols_a = st.number_input("Columnas de A:", min_value=1, max_value=10, value=3, step=1, key="mult_cols_a")
            
            A = []
            for i in range(int(filas_a)):
                fila = []
                cols_input = st.columns(int(cols_a))
                for j in range(int(cols_a)):
                    with cols_input[j]:
                        val = st.number_input(f"A[{i+1},{j+1}]", value=1.0, key=f"mult_a_{i}_{j}", format="%.2f")
                        fila.append(val)
                A.append(fila)
            A = np.array(A)
        
        with col2:
            st.write("**Matriz B:**")
            filas_b = int(cols_a)  # Debe coincidir con columnas de A
            st.write(f"Filas de B: {filas_b} (fijo)")
            cols_b = st.number_input("Columnas de B:", min_value=1, max_value=10, value=2, step=1, key="mult_cols_b")
            
            B = []
            for i in range(filas_b):
                fila = []
                cols_input = st.columns(int(cols_b))
                for j in range(int(cols_b)):
                    with cols_input[j]:
                        val = st.number_input(f"B[{i+1},{j+1}]", value=1.0, key=f"mult_b_{i}_{j}", format="%.2f")
                        fila.append(val)
                B.append(fila)
            B = np.array(B)
        
        if st.button("‚úñÔ∏è Calcular Multiplicaci√≥n", type="primary"):
            resultado = np.dot(A, B)
            st.success(f"‚úÖ Multiplicaci√≥n calculada (resultado: {resultado.shape[0]}√ó{resultado.shape[1]})")
            st.write("**Resultado: A √ó B =**")
            st.dataframe(pd.DataFrame(resultado), use_container_width=True)
    
    elif operacion == "Determinante":
        st.info("üî¢ Calcula el determinante de una matriz cuadrada")
        
        n = st.number_input("Tama√±o de la matriz (n√ón):", min_value=2, max_value=10, value=3, step=1, key="det_n")
        
        st.write("**Matriz A:**")
        A = []
        for i in range(int(n)):
            fila = []
            cols_input = st.columns(int(n))
            for j in range(int(n)):
                with cols_input[j]:
                    val = st.number_input(f"A[{i+1},{j+1}]", value=1.0 if i==j else 0.0, key=f"det_a_{i}_{j}", format="%.2f")
                    fila.append(val)
            A.append(fila)
        A = np.array(A)
        
        if st.button("üî¢ Calcular Determinante", type="primary"):
            det = np.linalg.det(A)
            st.success("‚úÖ Determinante calculado")
            st.metric("Determinante de A", f"{det:.6f}")
            
            if abs(det) < 1e-10:
                st.warning("‚ö†Ô∏è La matriz es singular (no invertible)")
            else:
                st.info("‚úÖ La matriz es invertible")
    
    elif operacion == "Inversa de matriz":
        st.info("üîÑ Calcula la matriz inversa de una matriz cuadrada")
        
        n = st.number_input("Tama√±o de la matriz (n√ón):", min_value=2, max_value=10, value=3, step=1, key="inv_n")
        
        st.write("**Matriz A:**")
        A = []
        for i in range(int(n)):
            fila = []
            cols_input = st.columns(int(n))
            for j in range(int(n)):
                with cols_input[j]:
                    val = st.number_input(f"A[{i+1},{j+1}]", value=1.0 if i==j else 0.0, key=f"inv_a_{i}_{j}", format="%.2f")
                    fila.append(val)
            A.append(fila)
        A = np.array(A)
        
        if st.button("üîÑ Calcular Inversa", type="primary"):
            try:
                det = np.linalg.det(A)
                if abs(det) < 1e-10:
                    st.error("‚ö†Ô∏è La matriz no es invertible (determinante ‚âà 0)")
                else:
                    inv = np.linalg.inv(A)
                    st.success("‚úÖ Inversa calculada")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.write("**Matriz original A:**")
                        st.dataframe(pd.DataFrame(A), use_container_width=True)
                    
                    with col2:
                        st.write("**Inversa A‚Åª¬π:**")
                        st.dataframe(pd.DataFrame(inv), use_container_width=True)
                    
                    # Verificaci√≥n
                    producto = np.dot(A, inv)
                    st.write("**Verificaci√≥n: A √ó A‚Åª¬π ‚âà I**")
                    st.dataframe(pd.DataFrame(producto), use_container_width=True)
            
            except np.linalg.LinAlgError:
                st.error("‚ùå Error: La matriz no es invertible")


# ==========
# MEN√ö PRINCIPAL
# ==========

def main():
    # T√≠tulo principal
    st.title("üßÆ Calculadora de M√©todos Num√©ricos")
    st.markdown("### üìö Proyecto de Modelado Computacional")
    st.markdown("---")
    
    # Sidebar para navegaci√≥n
    st.sidebar.header("üóÇÔ∏è Men√∫ de M√©todos")
    
    categoria = st.sidebar.radio(
        "Selecciona la categor√≠a:",
        ["üè† Inicio", "üìä Sistemas No Lineales", "üìê Sistemas de Ecuaciones Lineales", "üî¢ √Ålgebra Matricial"]
    )
    
    if categoria == "üè† Inicio":
        st.header("üëã Bienvenido")
        
        st.markdown("""
        Esta aplicaci√≥n web implementa diversos **m√©todos num√©ricos** estudiados en el curso de Modelado Computacional.
        
        ### üìö Contenido disponible:
        
        #### 1Ô∏è‚É£ **Sistemas No Lineales**
        - üîç M√©todo de Bisecci√≥n
        - üìê M√©todo de la Secante
        - üî¢ Newton-Raphson (2 variables)
        - üî¢ Newton-Raphson (3 variables)
        - üî¢ Newton-Raphson Modificado (2 variables)
        - üî¢ Newton-Raphson Modificado (3 variables)
        - üîÑ M√©todo de Punto Fijo (2 variables)
        - üîÑ M√©todo de Punto Fijo (3 variables)
        
        #### 2Ô∏è‚É£ **Sistemas de Ecuaciones Lineales**
        
        **M√©todos Directos:**
        - üîÑ M√©todo de la Inversa
        - ‚ûó Eliminaci√≥n de Gauss
        - üìä Gauss-Jordan
        
        **M√©todos Iterativos:**
        - üîÅ Jacobi
        - üîÅ Gauss-Seidel
        
        #### 3Ô∏è‚É£ **√Ålgebra Matricial**
        - ‚ûï Suma de matrices
        - ‚úñÔ∏è Multiplicaci√≥n de matrices
        - üî¢ Determinante
        - üîÑ Inversa de matriz
        
        ---
        
        ### üöÄ ¬øC√≥mo usar esta aplicaci√≥n?
        
        1. Selecciona una categor√≠a en el men√∫ lateral
        2. Elige el m√©todo espec√≠fico que quieres usar
        3. Ingresa los par√°metros requeridos
        4. Presiona el bot√≥n "Calcular"
        5. Visualiza los resultados, gr√°ficas y tablas
        6. Descarga los datos en formato CSV si lo necesitas
        
        ---
        
        ### üìñ Notas importantes:
        
        - Las funciones se ingresan usando notaci√≥n Python: `**` para potencias, `sin(x)`, `cos(x)`, `exp(x)`, `log(x)`, etc.
        - Los m√©todos iterativos muestran el historial completo de iteraciones
        - Todas las gr√°ficas son interactivas y puedes descargarlas
        - Los resultados se muestran con alta precisi√≥n (8 decimales)
        
        ---
        
        **üí° Tip:** Comienza con un m√©todo simple como Bisecci√≥n para familiarizarte con la interfaz.
        """)
        
        # Ejemplos r√°pidos
        with st.expander("üìù Ejemplos de funciones que puedes usar"):
            st.code("""
# Polinomiales
x**3 - x - 2
x**4 - x - 10
x**2 - 4

# Exponenciales
exp(x) - 3*x
2**x - x - 3

# Trigonom√©tricas
sin(x) - x/2
cos(x) - x
tan(x) - x

# Logar√≠tmicas
log(x) - 1/x
x*log(x) - 1

# Mixtas
exp(x) - 3*x**2 + 2*sin(x)
x**3 - cos(x) - 1
log(x+1) + x**2 - 3
            """, language="python")
    
    elif categoria == "üìä Sistemas No Lineales":
        st.sidebar.markdown("---")
        metodo_nl = st.sidebar.selectbox(
            "Elige un m√©todo:",
            ["Bisecci√≥n", "Secante", "Newton-Raphson (2V)", "Newton-Raphson (3V)", "Newton Modificado (2V)", "Newton Modificado (3V)", "Punto Fijo (2V)", "Punto Fijo (3V)"]
        )
        
        if metodo_nl == "Bisecci√≥n":
            metodo_biseccion_ui()
        elif metodo_nl == "Secante":
            metodo_secante_ui()
        elif metodo_nl == "Newton-Raphson (2V)":
            newton_raphson_2v_ui()
        elif metodo_nl == "Newton-Raphson (3V)":
            newton_raphson_3v_ui()
        elif metodo_nl == "Newton Modificado (2V)":
            newton_modificado_2v_ui()
        elif metodo_nl == "Newton Modificado (3V)":
            newton_modificado_3v_ui()
        elif metodo_nl == "Punto Fijo (2V)":
            punto_fijo_2v_ui()
        elif metodo_nl == "Punto Fijo (3V)":
            punto_fijo_3v_ui()
    
    elif categoria == "üìê Sistemas de Ecuaciones Lineales":
        sistemas_lineales_ui()
    
    elif categoria == "üî¢ √Ålgebra Matricial":
        algebra_matricial_ui()
    
    # Footer
    st.sidebar.markdown("---")
    st.sidebar.markdown("### üë®‚Äçüéì Informaci√≥n")
    st.sidebar.info("""
    **Proyecto:** M√©todos Num√©ricos
    
    **Curso:** Modelado Computacional
    
    **Tecnolog√≠as:**
    - Python 3
    - Streamlit
    - NumPy
    - Matplotlib
    - SciPy
    - SymPy
    """)
    
    st.sidebar.success("‚úÖ Aplicaci√≥n lista para usar")


# Ejecutar la aplicaci√≥n
if __name__ == "__main__":
    main()